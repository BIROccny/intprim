<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>intprim: intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">intprim
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>intprim</b></li><li class="navelem"><b>filter</b></li><li class="navelem"><b>spatiotemporal</b></li><li class="navelem"><b>enkf</b></li><li class="navelem"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html">EnsembleKalmanFilter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html" title="The EnsembleKalmanFilter class localizes an interaction in time and space via Monte Carlo approximati...">EnsembleKalmanFilter</a> class localizes an interaction in time and space via Monte Carlo approximation of the Kalman filter.  
 <a href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.png" usemap="#intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter_map" alt=""/>
  <map id="intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter_map" name="intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter_map">
<area href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html" title="The NonLinearSystem class provides general methods which are required by all the nonlinear filtering ..." alt="intprim.filter.spatiotemporal.nonlinear_system.NonLinearSystem" shape="rect" coords="189,56,557,80"/>
<area href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html" title="The NonLinearSystem class provides general methods which are required by all the nonlinear filtering ..." alt="intprim.filter.spatiotemporal.nonlinear_system.NonLinearSystem" shape="rect" coords="945,56,1313,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaec5afbf65835c0715a9c9b3fac856c9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#aaec5afbf65835c0715a9c9b3fac856c9">__init__</a> (self, basis_model, initial_phase_mean, initial_phase_var, proc_var, initial_ensemble, time_delta=1.0, cyclical=False)</td></tr>
<tr class="memdesc:aaec5afbf65835c0715a9c9b3fac856c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initialization method for the <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html" title="The EnsembleKalmanFilter class localizes an interaction in time and space via Monte Carlo approximati...">EnsembleKalmanFilter</a>.  <a href="#aaec5afbf65835c0715a9c9b3fac856c9">More...</a><br /></td></tr>
<tr class="separator:aaec5afbf65835c0715a9c9b3fac856c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15c4443be148e07e9069f0b8b11f74c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#ab15c4443be148e07e9069f0b8b11f74c">get_ensemble_mean</a> (self, ensemble=None)</td></tr>
<tr class="memdesc:ab15c4443be148e07e9069f0b8b11f74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the unbiased sample mean of the ensemble.  <a href="#ab15c4443be148e07e9069f0b8b11f74c">More...</a><br /></td></tr>
<tr class="separator:ab15c4443be148e07e9069f0b8b11f74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c976650038c1279978b58b032d04399"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#a7c976650038c1279978b58b032d04399">get_ensemble_covariance</a> (self, ensemble=None)</td></tr>
<tr class="memdesc:a7c976650038c1279978b58b032d04399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the unbiased sample covariance of the ensemble.  <a href="#a7c976650038c1279978b58b032d04399">More...</a><br /></td></tr>
<tr class="separator:a7c976650038c1279978b58b032d04399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1151fe96398140180310aeb73c2e7dce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#a1151fe96398140180310aeb73c2e7dce">get_projected_mean_covariance</a> (self, phase, ensemble=None)</td></tr>
<tr class="memdesc:a1151fe96398140180310aeb73c2e7dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the unbiased sample mean and covariance of the ensemble projected into the observation space.  <a href="#a1151fe96398140180310aeb73c2e7dce">More...</a><br /></td></tr>
<tr class="separator:a1151fe96398140180310aeb73c2e7dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd634c25f64b7ca7d4b94d3cbe7a1fbd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#abd634c25f64b7ca7d4b94d3cbe7a1fbd">h</a> (self, state)</td></tr>
<tr class="memdesc:abd634c25f64b7ca7d4b94d3cbe7a1fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nonlinear observation function \( h(\cdot) \) which maps an input state of dimension \( \mathbb{R}^{B} \) to an output observation of dimension \( \mathbb{R}^D. \) This is simply the dot product of the basis functions to the corresponding basis weights.  <a href="#abd634c25f64b7ca7d4b94d3cbe7a1fbd">More...</a><br /></td></tr>
<tr class="separator:abd634c25f64b7ca7d4b94d3cbe7a1fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34df1b3b245e8448f2e96e9d06ca6d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#ae34df1b3b245e8448f2e96e9d06ca6d4">hx</a> (self, output_matrix)</td></tr>
<tr class="memdesc:ae34df1b3b245e8448f2e96e9d06ca6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the projection of the ensemble to the observation space.  <a href="#ae34df1b3b245e8448f2e96e9d06ca6d4">More...</a><br /></td></tr>
<tr class="separator:ae34df1b3b245e8448f2e96e9d06ca6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553b49a90c17fcafa80016812aaf5ea4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#a553b49a90c17fcafa80016812aaf5ea4">localize</a> (self, measurement, measurement_noise, active_dofs, return_phase_variance=False)</td></tr>
<tr class="memdesc:a553b49a90c17fcafa80016812aaf5ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method performs simultaneous localization of both time (phase) and space (basis weights).  <a href="#a553b49a90c17fcafa80016812aaf5ea4">More...</a><br /></td></tr>
<tr class="separator:a553b49a90c17fcafa80016812aaf5ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec5afbf65835c0715a9c9b3fac856c9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#aaec5afbf65835c0715a9c9b3fac856c9">__init__</a> (self, basis_model, initial_phase_mean, initial_phase_var, proc_var, initial_ensemble, time_delta=1.0, cyclical=False)</td></tr>
<tr class="memdesc:aaec5afbf65835c0715a9c9b3fac856c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The initialization method for the <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html" title="The EnsembleKalmanFilter class localizes an interaction in time and space via Monte Carlo approximati...">EnsembleKalmanFilter</a>.  <a href="#aaec5afbf65835c0715a9c9b3fac856c9">More...</a><br /></td></tr>
<tr class="separator:aaec5afbf65835c0715a9c9b3fac856c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15c4443be148e07e9069f0b8b11f74c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#ab15c4443be148e07e9069f0b8b11f74c">get_ensemble_mean</a> (self, ensemble=None)</td></tr>
<tr class="memdesc:ab15c4443be148e07e9069f0b8b11f74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the unbiased sample mean of the ensemble.  <a href="#ab15c4443be148e07e9069f0b8b11f74c">More...</a><br /></td></tr>
<tr class="separator:ab15c4443be148e07e9069f0b8b11f74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c976650038c1279978b58b032d04399"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#a7c976650038c1279978b58b032d04399">get_ensemble_covariance</a> (self, ensemble=None)</td></tr>
<tr class="memdesc:a7c976650038c1279978b58b032d04399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the unbiased sample covariance of the ensemble.  <a href="#a7c976650038c1279978b58b032d04399">More...</a><br /></td></tr>
<tr class="separator:a7c976650038c1279978b58b032d04399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1151fe96398140180310aeb73c2e7dce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#a1151fe96398140180310aeb73c2e7dce">get_projected_mean_covariance</a> (self, phase, ensemble=None)</td></tr>
<tr class="memdesc:a1151fe96398140180310aeb73c2e7dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the unbiased sample mean and covariance of the ensemble projected into the observation space.  <a href="#a1151fe96398140180310aeb73c2e7dce">More...</a><br /></td></tr>
<tr class="separator:a1151fe96398140180310aeb73c2e7dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd634c25f64b7ca7d4b94d3cbe7a1fbd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#abd634c25f64b7ca7d4b94d3cbe7a1fbd">h</a> (self, state)</td></tr>
<tr class="memdesc:abd634c25f64b7ca7d4b94d3cbe7a1fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The nonlinear observation function \( h(\cdot) \) which maps an input state of dimension \( \mathbb{R}^{B} \) to an output observation of dimension \( \mathbb{R}^D. \) This is simply the dot product of the basis functions to the corresponding basis weights.  <a href="#abd634c25f64b7ca7d4b94d3cbe7a1fbd">More...</a><br /></td></tr>
<tr class="separator:abd634c25f64b7ca7d4b94d3cbe7a1fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34df1b3b245e8448f2e96e9d06ca6d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#ae34df1b3b245e8448f2e96e9d06ca6d4">hx</a> (self, output_matrix)</td></tr>
<tr class="memdesc:ae34df1b3b245e8448f2e96e9d06ca6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the projection of the ensemble to the observation space.  <a href="#ae34df1b3b245e8448f2e96e9d06ca6d4">More...</a><br /></td></tr>
<tr class="separator:ae34df1b3b245e8448f2e96e9d06ca6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553b49a90c17fcafa80016812aaf5ea4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#a553b49a90c17fcafa80016812aaf5ea4">localize</a> (self, measurement, measurement_noise, active_dofs, return_phase_variance=False)</td></tr>
<tr class="memdesc:a553b49a90c17fcafa80016812aaf5ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method performs simultaneous localization of both time (phase) and space (basis weights).  <a href="#a553b49a90c17fcafa80016812aaf5ea4">More...</a><br /></td></tr>
<tr class="separator:a553b49a90c17fcafa80016812aaf5ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html">intprim.filter.spatiotemporal.nonlinear_system.NonLinearSystem</a></td></tr>
<tr class="memitem:a49c2c9f9a7801e26625e29c0bc7ddade inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html#a49c2c9f9a7801e26625e29c0bc7ddade">__init__</a> (self, basis_model, proc_var, time_delta, system_order)</td></tr>
<tr class="memdesc:a49c2c9f9a7801e26625e29c0bc7ddade inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html" title="The NonLinearSystem class provides general methods which are required by all the nonlinear filtering ...">NonLinearSystem</a>.  <a href="#a49c2c9f9a7801e26625e29c0bc7ddade">More...</a><br /></td></tr>
<tr class="separator:a49c2c9f9a7801e26625e29c0bc7ddade inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1733f1ebfe4d35d9f6414d25bc5588f1 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html#a1733f1ebfe4d35d9f6414d25bc5588f1">get_transition_model</a> (self)</td></tr>
<tr class="memdesc:a1733f1ebfe4d35d9f6414d25bc5588f1 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transition model for spatiotemporal filtering.  <a href="#a1733f1ebfe4d35d9f6414d25bc5588f1">More...</a><br /></td></tr>
<tr class="separator:a1733f1ebfe4d35d9f6414d25bc5588f1 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfac79d366b571dc07e8801e6ee162a0 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html#adfac79d366b571dc07e8801e6ee162a0">get_process_noise</a> (self)</td></tr>
<tr class="memdesc:adfac79d366b571dc07e8801e6ee162a0 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the process noise for spatiotemporal filtering.  <a href="#adfac79d366b571dc07e8801e6ee162a0">More...</a><br /></td></tr>
<tr class="separator:adfac79d366b571dc07e8801e6ee162a0 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa84399039f258adafaa0869565f81c6 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html#aaa84399039f258adafaa0869565f81c6">get_phase_process_noise</a> (self)</td></tr>
<tr class="memdesc:aaa84399039f258adafaa0869565f81c6 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the process noise specifically for the constant velocity phase system.  <a href="#aaa84399039f258adafaa0869565f81c6">More...</a><br /></td></tr>
<tr class="separator:aaa84399039f258adafaa0869565f81c6 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fbf9ce2cc4e8bad3147ebe0051df37 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html#a70fbf9ce2cc4e8bad3147ebe0051df37">get_measurement_model</a> (self, x)</td></tr>
<tr class="memdesc:a70fbf9ce2cc4e8bad3147ebe0051df37 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the measurement model for spatiotemporal filtering.  <a href="#a70fbf9ce2cc4e8bad3147ebe0051df37">More...</a><br /></td></tr>
<tr class="separator:a70fbf9ce2cc4e8bad3147ebe0051df37 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c2c9f9a7801e26625e29c0bc7ddade inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html#a49c2c9f9a7801e26625e29c0bc7ddade">__init__</a> (self, basis_model, proc_var, time_delta, system_order)</td></tr>
<tr class="memdesc:a49c2c9f9a7801e26625e29c0bc7ddade inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html" title="The NonLinearSystem class provides general methods which are required by all the nonlinear filtering ...">NonLinearSystem</a>.  <a href="#a49c2c9f9a7801e26625e29c0bc7ddade">More...</a><br /></td></tr>
<tr class="separator:a49c2c9f9a7801e26625e29c0bc7ddade inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1733f1ebfe4d35d9f6414d25bc5588f1 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html#a1733f1ebfe4d35d9f6414d25bc5588f1">get_transition_model</a> (self)</td></tr>
<tr class="memdesc:a1733f1ebfe4d35d9f6414d25bc5588f1 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the transition model for spatiotemporal filtering.  <a href="#a1733f1ebfe4d35d9f6414d25bc5588f1">More...</a><br /></td></tr>
<tr class="separator:a1733f1ebfe4d35d9f6414d25bc5588f1 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfac79d366b571dc07e8801e6ee162a0 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html#adfac79d366b571dc07e8801e6ee162a0">get_process_noise</a> (self)</td></tr>
<tr class="memdesc:adfac79d366b571dc07e8801e6ee162a0 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the process noise for spatiotemporal filtering.  <a href="#adfac79d366b571dc07e8801e6ee162a0">More...</a><br /></td></tr>
<tr class="separator:adfac79d366b571dc07e8801e6ee162a0 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa84399039f258adafaa0869565f81c6 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html#aaa84399039f258adafaa0869565f81c6">get_phase_process_noise</a> (self)</td></tr>
<tr class="memdesc:aaa84399039f258adafaa0869565f81c6 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the process noise specifically for the constant velocity phase system.  <a href="#aaa84399039f258adafaa0869565f81c6">More...</a><br /></td></tr>
<tr class="separator:aaa84399039f258adafaa0869565f81c6 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fbf9ce2cc4e8bad3147ebe0051df37 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html#a70fbf9ce2cc4e8bad3147ebe0051df37">get_measurement_model</a> (self, x)</td></tr>
<tr class="memdesc:a70fbf9ce2cc4e8bad3147ebe0051df37 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the measurement model for spatiotemporal filtering.  <a href="#a70fbf9ce2cc4e8bad3147ebe0051df37">More...</a><br /></td></tr>
<tr class="separator:a70fbf9ce2cc4e8bad3147ebe0051df37 inherit pub_methods_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2060ba9fac823cc9a8395245f513226e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2060ba9fac823cc9a8395245f513226e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ensemble_size</b></td></tr>
<tr class="separator:a2060ba9fac823cc9a8395245f513226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77accf04bbffb242830a8dac1f4d383"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae77accf04bbffb242830a8dac1f4d383"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>cyclical</b></td></tr>
<tr class="separator:ae77accf04bbffb242830a8dac1f4d383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb8e806d7ad69f4b5f8122c0165fa59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bb8e806d7ad69f4b5f8122c0165fa59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ensemble</b></td></tr>
<tr class="separator:a0bb8e806d7ad69f4b5f8122c0165fa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem.html">intprim.filter.spatiotemporal.nonlinear_system.NonLinearSystem</a></td></tr>
<tr class="memitem:a565cc4487708c295aebe93fcf92e2c29 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a565cc4487708c295aebe93fcf92e2c29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>system_order</b></td></tr>
<tr class="separator:a565cc4487708c295aebe93fcf92e2c29 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6c202320625e9c9e91d87887f7c524 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb6c202320625e9c9e91d87887f7c524"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>system_size</b></td></tr>
<tr class="separator:abb6c202320625e9c9e91d87887f7c524 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059e594bc4792e89f3fa0cdc77d29332 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a059e594bc4792e89f3fa0cdc77d29332"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>basis_model</b></td></tr>
<tr class="separator:a059e594bc4792e89f3fa0cdc77d29332 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c051adc5591496311280341a106cb11 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c051adc5591496311280341a106cb11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>state_dimension</b></td></tr>
<tr class="separator:a6c051adc5591496311280341a106cb11 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4573c61d17a1f0d0cdfc996331a72321 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4573c61d17a1f0d0cdfc996331a72321"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>measurement_dimension</b></td></tr>
<tr class="separator:a4573c61d17a1f0d0cdfc996331a72321 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba49be14a9776898ddb1b70500ef271c inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba49be14a9776898ddb1b70500ef271c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>proc_var</b></td></tr>
<tr class="separator:aba49be14a9776898ddb1b70500ef271c inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b27906c785e1d6adc65242d44f8bcf inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67b27906c785e1d6adc65242d44f8bcf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>time_delta</b></td></tr>
<tr class="separator:a67b27906c785e1d6adc65242d44f8bcf inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab477e12c986f782cdd7cccf15e1b1e07 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab477e12c986f782cdd7cccf15e1b1e07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>process_noise</b></td></tr>
<tr class="separator:ab477e12c986f782cdd7cccf15e1b1e07 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ace5dec46f9ac47c939174e42a44df3 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ace5dec46f9ac47c939174e42a44df3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>transition_model</b></td></tr>
<tr class="separator:a6ace5dec46f9ac47c939174e42a44df3 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764d86a848e17a327beae9fa435d1977 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a764d86a848e17a327beae9fa435d1977"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>phase_process_noise</b></td></tr>
<tr class="separator:a764d86a848e17a327beae9fa435d1977 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797367718c2acf093dac9d33c67ecf22 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a797367718c2acf093dac9d33c67ecf22"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>measurement_model_prototype</b></td></tr>
<tr class="separator:a797367718c2acf093dac9d33c67ecf22 inherit pub_attribs_classintprim_1_1filter_1_1spatiotemporal_1_1nonlinear__system_1_1NonLinearSystem"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html" title="The EnsembleKalmanFilter class localizes an interaction in time and space via Monte Carlo approximati...">EnsembleKalmanFilter</a> class localizes an interaction in time and space via Monte Carlo approximation of the Kalman filter. </p>
<p>This class is a recursive filter, meaning it maintains state information between successive calls to <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#a553b49a90c17fcafa80016812aaf5ea4" title="This method performs simultaneous localization of both time (phase) and space (basis weights)...">localize()</a>. As with the other spatiotemporal filters, the <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html" title="The EnsembleKalmanFilter class localizes an interaction in time and space via Monte Carlo approximati...">EnsembleKalmanFilter</a>'s internal state consists of (N+1) dimensions modeling the N-th order phase system plus B dimensions modeling the latent space of the interaction. However, unlike the ExtendedKalmanFilter, this class does not maintain a single explicit state instance. Instead, an internal ensemble of E members is maintained, such that the ensemble matrix dimension is (N+1)+B x E. As a result, no explicit covariance matrix is maintained. Instead, the covariance is modeled implicitly in the ensemble via the sample covariance. This class corresponds to an Ensemble Bayesian Interaction Primitive.</p>
<p>References:<br />
 Campbell, J., Stepputtis, S., &amp; Ben Amor, H. (2019). Probabilistic Multimodal Modeling for Human-Robot Interaction Tasks.<br />
 Evensen, G. (2003). The ensemble Kalman filter: Theoretical formulation and practical implementation. Ocean dynamics, 53(4), 343-367.<br />
</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaec5afbf65835c0715a9c9b3fac856c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basis_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_phase_mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_phase_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proc_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_ensemble</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time_delta</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cyclical</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initialization method for the <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html" title="The EnsembleKalmanFilter class localizes an interaction in time and space via Monte Carlo approximati...">EnsembleKalmanFilter</a>. </p>
<p>Responsible for creating the initial ensemble.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_model</td><td>The basis model corresponding to this state space. </td></tr>
    <tr><td class="paramname">initial_phase_mean</td><td>Vector of dimension N corresponding to the initial mean of the constant velocity phase system. If this is a 0th order system, should contain only [phase_mean]. If this is 1st order, should contain [phase_mean, phase_velocity]. If this is 2nd order, should contain [phase_mean, phase_velocity, phase_acceleration]. Anything above 2nd order is not supported. </td></tr>
    <tr><td class="paramname">initial_phase_var</td><td>Vector of dimension N corresponding to the diagonal of the initial covariance of the constant velocity phase system. If this is a 0th order system, should contain only [phase_var]. If this is 1st order, should contain [phase_var, phase_velocity_var]. If this is 2nd order, should contain [phase_var, phase_velocity_var, phase_acceleration_var]. Anything above 2nd order is not supported. </td></tr>
    <tr><td class="paramname">proc_var</td><td>The process noise of the constant velocity phase system. This is a scalar value corresponding to the variance of a piecewise white noise model. </td></tr>
    <tr><td class="paramname">initial_ensemble</td><td>Matrix of dimension E x B which represents an initial ensemble. Typically, this is just the set of basis weights corresponding to E training demonstrations. </td></tr>
    <tr><td class="paramname">time_delta</td><td>The amount of time that elapses between time steps. This serves as a scaling factor to the constant velocity phase system. In most cases, this should be set to 1.0. </td></tr>
    <tr><td class="paramname">cyclical</td><td>Indicates whether this is a cyclical primitive. If True, the internal phase state will cycle back to 0 once it exceeds 1, allowing for continuous inference of periodic interactions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaec5afbf65835c0715a9c9b3fac856c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basis_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_phase_mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_phase_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proc_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_ensemble</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>time_delta</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cyclical</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The initialization method for the <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html" title="The EnsembleKalmanFilter class localizes an interaction in time and space via Monte Carlo approximati...">EnsembleKalmanFilter</a>. </p>
<p>Responsible for creating the initial ensemble.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_model</td><td>The basis model corresponding to this state space. </td></tr>
    <tr><td class="paramname">initial_phase_mean</td><td>Vector of dimension N corresponding to the initial mean of the constant velocity phase system. If this is a 0th order system, should contain only [phase_mean]. If this is 1st order, should contain [phase_mean, phase_velocity]. If this is 2nd order, should contain [phase_mean, phase_velocity, phase_acceleration]. Anything above 2nd order is not supported. </td></tr>
    <tr><td class="paramname">initial_phase_var</td><td>Vector of dimension N corresponding to the diagonal of the initial covariance of the constant velocity phase system. If this is a 0th order system, should contain only [phase_var]. If this is 1st order, should contain [phase_var, phase_velocity_var]. If this is 2nd order, should contain [phase_var, phase_velocity_var, phase_acceleration_var]. Anything above 2nd order is not supported. </td></tr>
    <tr><td class="paramname">proc_var</td><td>The process noise of the constant velocity phase system. This is a scalar value corresponding to the variance of a piecewise white noise model. </td></tr>
    <tr><td class="paramname">initial_ensemble</td><td>Matrix of dimension E x B which represents an initial ensemble. Typically, this is just the set of basis weights corresponding to E training demonstrations. </td></tr>
    <tr><td class="paramname">time_delta</td><td>The amount of time that elapses between time steps. This serves as a scaling factor to the constant velocity phase system. In most cases, this should be set to 1.0. </td></tr>
    <tr><td class="paramname">cyclical</td><td>Indicates whether this is a cyclical primitive. If True, the internal phase state will cycle back to 0 once it exceeds 1, allowing for continuous inference of periodic interactions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7c976650038c1279978b58b032d04399"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.get_ensemble_covariance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensemble</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the unbiased sample covariance of the ensemble. </p>
<p>The formula used to compute the covariance is: $$ cov(\boldsymbol{X}) = \frac{1}{E - 1} \boldsymbol{A} \boldsymbol{A}^{T}, \qquad \boldsymbol{A} = \boldsymbol{X} - \bar{\boldsymbol{X}}, $$ where \( cov(\boldsymbol{X}) \in \mathbb{R}^{N+1+B \times N+1+B}. \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble</td><td>The ensemble from which to calculate the sample covariance. If none, uses the internal state ensemble.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of dimension N+1+B x N+1+B containing the sample covariance. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c976650038c1279978b58b032d04399"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.get_ensemble_covariance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensemble</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the unbiased sample covariance of the ensemble. </p>
<p>The formula used to compute the covariance is: $$ cov(\boldsymbol{X}) = \frac{1}{E - 1} \boldsymbol{A} \boldsymbol{A}^{T}, \qquad \boldsymbol{A} = \boldsymbol{X} - \bar{\boldsymbol{X}}, $$ where \( cov(\boldsymbol{X}) \in \mathbb{R}^{N+1+B \times N+1+B}. \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble</td><td>The ensemble from which to calculate the sample covariance. If none, uses the internal state ensemble.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of dimension N+1+B x N+1+B containing the sample covariance. </dd></dl>

</div>
</div>
<a class="anchor" id="ab15c4443be148e07e9069f0b8b11f74c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.get_ensemble_mean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensemble</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the unbiased sample mean of the ensemble. </p>
<p>The formula used to compute the mean is: $$ \bar{\boldsymbol{X}} = \frac{1}{E} \sum_{j=1}^{E} \boldsymbol{x}^{j}, $$ where \( \boldsymbol{x}^{j} \in \mathbb{R}^{N+1+B} \) and \( \bar{\boldsymbol{X}} \in \mathbb{R}^{N+1+B}. \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble</td><td>The ensemble from which to calculate the sample mean. If None, uses the internal state ensemble.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of dimension N+1+B containing the sample mean. </dd></dl>

</div>
</div>
<a class="anchor" id="ab15c4443be148e07e9069f0b8b11f74c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.get_ensemble_mean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensemble</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the unbiased sample mean of the ensemble. </p>
<p>The formula used to compute the mean is: $$ \bar{\boldsymbol{X}} = \frac{1}{E} \sum_{j=1}^{E} \boldsymbol{x}^{j}, $$ where \( \boldsymbol{x}^{j} \in \mathbb{R}^{N+1+B} \) and \( \bar{\boldsymbol{X}} \in \mathbb{R}^{N+1+B}. \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ensemble</td><td>The ensemble from which to calculate the sample mean. If None, uses the internal state ensemble.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of dimension N+1+B containing the sample mean. </dd></dl>

</div>
</div>
<a class="anchor" id="a1151fe96398140180310aeb73c2e7dce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.get_projected_mean_covariance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensemble</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the unbiased sample mean and covariance of the ensemble projected into the observation space. </p>
<p>This is computed by first projecting the entire ensemble to measurement space then calculating the sample covariance. Mathematically, calculating the sample covariance and then projecting it should be equivalent but numerical issues sometimes arise and so this method is preferred. The formula used to compute the covariance is: $$ cov(\boldsymbol{H} \boldsymbol{X}) = \frac{1}{E - 1} (\boldsymbol{H}\boldsymbol{A}) (\boldsymbol{H} \boldsymbol{A}^{T}), \qquad \boldsymbol{H} \boldsymbol{A} = \boldsymbol{X} - \frac{1}{E} \sum_{j=1}^{E}h(\boldsymbol{x}^j), $$ where \( cov(\boldsymbol{H} \boldsymbol{X}) \in \mathbb{R}^{D \times D} \) and \( h(\cdot) \) is the nonlinear observation function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phase</td><td>The phase value \( \phi \) to use for the projection. </td></tr>
    <tr><td class="paramname">ensemble</td><td>The ensemble from which to calculate the projected mean and covariance. If none, uses the internal state ensemble.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of dimension D containing the sample mean, matrix of dimension D x D containing the sample covariance. </dd></dl>

</div>
</div>
<a class="anchor" id="a1151fe96398140180310aeb73c2e7dce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.get_projected_mean_covariance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ensemble</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the unbiased sample mean and covariance of the ensemble projected into the observation space. </p>
<p>This is computed by first projecting the entire ensemble to measurement space then calculating the sample covariance. Mathematically, calculating the sample covariance and then projecting it should be equivalent but numerical issues sometimes arise and so this method is preferred. The formula used to compute the covariance is: $$ cov(\boldsymbol{H} \boldsymbol{X}) = \frac{1}{E - 1} (\boldsymbol{H}\boldsymbol{A}) (\boldsymbol{H} \boldsymbol{A}^{T}), \qquad \boldsymbol{H} \boldsymbol{A} = \boldsymbol{X} - \frac{1}{E} \sum_{j=1}^{E}h(\boldsymbol{x}^j), $$ where \( cov(\boldsymbol{H} \boldsymbol{X}) \in \mathbb{R}^{D \times D} \) and \( h(\cdot) \) is the nonlinear observation function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phase</td><td>The phase value \( \phi \) to use for the projection. </td></tr>
    <tr><td class="paramname">ensemble</td><td>The ensemble from which to calculate the projected mean and covariance. If none, uses the internal state ensemble.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of dimension D containing the sample mean, matrix of dimension D x D containing the sample covariance. </dd></dl>

</div>
</div>
<a class="anchor" id="abd634c25f64b7ca7d4b94d3cbe7a1fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.h </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The nonlinear observation function \( h(\cdot) \) which maps an input state of dimension \( \mathbb{R}^{B} \) to an output observation of dimension \( \mathbb{R}^D. \) This is simply the dot product of the basis functions to the corresponding basis weights. </p>
<p>The nonlinearity comes from the usage of the phase state variable as a parameter to the basis functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Vector of dimension N+1+B which is the state to be projected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of dimension D containing the projected state. </dd></dl>

</div>
</div>
<a class="anchor" id="abd634c25f64b7ca7d4b94d3cbe7a1fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.h </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The nonlinear observation function \( h(\cdot) \) which maps an input state of dimension \( \mathbb{R}^{B} \) to an output observation of dimension \( \mathbb{R}^D. \) This is simply the dot product of the basis functions to the corresponding basis weights. </p>
<p>The nonlinearity comes from the usage of the phase state variable as a parameter to the basis functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Vector of dimension N+1+B which is the state to be projected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of dimension D containing the projected state. </dd></dl>

</div>
</div>
<a class="anchor" id="ae34df1b3b245e8448f2e96e9d06ca6d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.hx </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method computes the projection of the ensemble to the observation space. </p>
<p>Each member is projected such that the input ensemble is mapped from \( \mathbb{R}^{N+1+B \times E} \) to \( \mathbb{R}^{D \times E} \). The formula used to compute this is: $$ \boldsymbol{H} \boldsymbol{X} = \left[h(\boldsymbol{x}^1), \dots, h(\boldsymbol{x}^E) \right]. $$</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_matrix</td><td>Matrix of dimension D x E in which the results should be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae34df1b3b245e8448f2e96e9d06ca6d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.hx </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method computes the projection of the ensemble to the observation space. </p>
<p>Each member is projected such that the input ensemble is mapped from \( \mathbb{R}^{N+1+B \times E} \) to \( \mathbb{R}^{D \times E} \). The formula used to compute this is: $$ \boldsymbol{H} \boldsymbol{X} = \left[h(\boldsymbol{x}^1), \dots, h(\boldsymbol{x}^E) \right]. $$</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_matrix</td><td>Matrix of dimension D x E in which the results should be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a553b49a90c17fcafa80016812aaf5ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.localize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>measurement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>measurement_noise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>active_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_phase_variance</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method performs simultaneous localization of both time (phase) and space (basis weights). </p>
<p>This is a recursive call, which means it updates the internal state estimate based on the given observations. For each observation given, two steps are performed recursively: First, the current ensemble is propagated forward in time in what is known as the prediction step. $$ \boldsymbol{x}^j_{t|t-1} = \boldsymbol{G} \boldsymbol{x}^j_{t-1|t-1} + \mathcal{N} \left(0, \boldsymbol{Q}_t\right), \quad 1 \leq j \leq E. $$ Note that in this case, we only apply the dot product to the first N+1 dimensions of the state. This is for computational efficiency as only the constant velocity phase system has a non-zero transition.</p>
<p>Next, we integrate the observations into the current ensemble in the update step. $$ \boldsymbol{H}_t\boldsymbol{A}_t = \boldsymbol{H}_t \boldsymbol{X}_{t|t-1} - \left[ \frac{1}{E} \sum_{j=1}^{E}h(\boldsymbol{x}^j_{t|t-1}), \dots, \frac{1}{E} \sum_{j=1}^{E}h(\boldsymbol{x}^j_{t|t-1}) \right], $$ $$ \boldsymbol{S}_t = \frac{1}{E - 1} (\boldsymbol{H}_t \boldsymbol{A}_t) (\boldsymbol{H}_t\boldsymbol{A}_t)^T + \boldsymbol{R}_t, $$ $$ \boldsymbol{A}_t = \boldsymbol{X}_{t|t-1} - \frac{1}{E} \sum_{j=1}^{E} \boldsymbol{x}^j_{t|t-1}, $$ $$ \boldsymbol{K}_t = \frac{1}{E - 1} \boldsymbol{A}_t (\boldsymbol{H}_t \boldsymbol{A}_t)^T \boldsymbol{S}^{-1}_t. $$</p>
<p>Lastly, the sample mean and covariance of the ensemble are returned. At the end of both the prediction and update steps the internal phase value is clipped such that it falls within the range [0, 1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measurement</td><td>Matrix of dimension T x D containing observations, where T is the number of timesteps that have been observed since the last call to <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#a553b49a90c17fcafa80016812aaf5ea4" title="This method performs simultaneous localization of both time (phase) and space (basis weights)...">localize()</a> and D is the dimension of the measurement space. </td></tr>
    <tr><td class="paramname">measurement_noise</td><td>Matrix of dimension D x D containing the measurement noise for the given set of measurements. </td></tr>
    <tr><td class="paramname">active_dofs</td><td>Vector of dimension \( D_o \) containing measurement space indices of the observed degrees of freedom. Note that the measurements will also contain unobserved degrees of freedom, but their values should not be used for inference. </td></tr>
    <tr><td class="paramname">return_phase_variance</td><td>True if the mean/variance for the phase system should be returned in addition to the basis weights.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar value containing the inferred phase, Vector of dimension D (or N+1+D if return_phase_variance is True) containing inferred mean, Matrix of dimension D x D (or N+1+D x N+1+D if return_phase_variance is True). </dd></dl>

</div>
</div>
<a class="anchor" id="a553b49a90c17fcafa80016812aaf5ea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def intprim.filter.spatiotemporal.enkf.EnsembleKalmanFilter.localize </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>measurement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>measurement_noise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>active_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_phase_variance</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method performs simultaneous localization of both time (phase) and space (basis weights). </p>
<p>This is a recursive call, which means it updates the internal state estimate based on the given observations. For each observation given, two steps are performed recursively: First, the current ensemble is propagated forward in time in what is known as the prediction step. $$ \boldsymbol{x}^j_{t|t-1} = \boldsymbol{G} \boldsymbol{x}^j_{t-1|t-1} + \mathcal{N} \left(0, \boldsymbol{Q}_t\right), \quad 1 \leq j \leq E. $$ Note that in this case, we only apply the dot product to the first N+1 dimensions of the state. This is for computational efficiency as only the constant velocity phase system has a non-zero transition.</p>
<p>Next, we integrate the observations into the current ensemble in the update step. $$ \boldsymbol{H}_t\boldsymbol{A}_t = \boldsymbol{H}_t \boldsymbol{X}_{t|t-1} - \left[ \frac{1}{E} \sum_{j=1}^{E}h(\boldsymbol{x}^j_{t|t-1}), \dots, \frac{1}{E} \sum_{j=1}^{E}h(\boldsymbol{x}^j_{t|t-1}) \right], $$ $$ \boldsymbol{S}_t = \frac{1}{E - 1} (\boldsymbol{H}_t \boldsymbol{A}_t) (\boldsymbol{H}_t\boldsymbol{A}_t)^T + \boldsymbol{R}_t, $$ $$ \boldsymbol{A}_t = \boldsymbol{X}_{t|t-1} - \frac{1}{E} \sum_{j=1}^{E} \boldsymbol{x}^j_{t|t-1}, $$ $$ \boldsymbol{K}_t = \frac{1}{E - 1} \boldsymbol{A}_t (\boldsymbol{H}_t \boldsymbol{A}_t)^T \boldsymbol{S}^{-1}_t. $$</p>
<p>Lastly, the sample mean and covariance of the ensemble are returned. At the end of both the prediction and update steps the internal phase value is clipped such that it falls within the range [0, 1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measurement</td><td>Matrix of dimension T x D containing observations, where T is the number of timesteps that have been observed since the last call to <a class="el" href="classintprim_1_1filter_1_1spatiotemporal_1_1enkf_1_1EnsembleKalmanFilter.html#a553b49a90c17fcafa80016812aaf5ea4" title="This method performs simultaneous localization of both time (phase) and space (basis weights)...">localize()</a> and D is the dimension of the measurement space. </td></tr>
    <tr><td class="paramname">measurement_noise</td><td>Matrix of dimension D x D containing the measurement noise for the given set of measurements. </td></tr>
    <tr><td class="paramname">active_dofs</td><td>Vector of dimension \( D_o \) containing measurement space indices of the observed degrees of freedom. Note that the measurements will also contain unobserved degrees of freedom, but their values should not be used for inference. </td></tr>
    <tr><td class="paramname">return_phase_variance</td><td>True if the mean/variance for the phase system should be returned in addition to the basis weights.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scalar value containing the inferred phase, Vector of dimension D (or N+1+D if return_phase_variance is True) containing inferred mean, Matrix of dimension D x D (or N+1+D x N+1+D if return_phase_variance is True). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/joe/LibraryPythonPkg/intprim/build/lib.linux-x86_64-2.7/intprim/filter/spatiotemporal/enkf.py</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
